1. Bubble Sort (버블 정렬)

장점 : 쉽고 간단하게 구현 가능하다.
단점 : 굉장히 비효율적이다. 어떤 경우던 O(N*2)의 시간복잡도를 갖는다.

2. Selection Sort (선택 정렬)

장점 : 버블 정렬처럼 구현이 쉬운 편에 속한다.
단점 : 단점도 버블 정렬처럼 O(N*2)의 시간복잡도를 갖는다. 물론 버블정렬보단 아주 약간 더 빠르다.

3. Quick Sort (퀵 정렬)

장점 : 위의 두 정렬보다 훨씬 빠른 시간인 O(NlogN)의 시간복잡도를 갖는다.
단점 : 기준값을 이상적인 값을 잡는다면 O(NlogN)의 시간복잡도를 갖지만, 최악의 값을 잡는 경우 O(N*2)의 시간복잡도를 갖는다.

4. Merge Sort (병합 정렬)

장점 : 퀵 정렬과 달리 항상 O(NlogN)의 시간복잡도를 갖는다.
단점 : 추가적인 메모리 공간을 필요로 하기 때문에 메모리 공간이 부족할 경우 사용할 수 없다.

5. Heap Sort (힙 정렬)

장점 : 병합 정렬처럼 항상 O(NlogN)의 시간복잡도를 갖는다.
단점 : O(NlogN)이라곤 하지만 실제로는 더 느리다고 하다.

6. Insertion Sort (삽입 정렬)

장점 : 최선의 경우 O(N)의 시간복잡도를 갖는다. (가장 빠름)
단점 : 최악의 경우 O(N*2)의 시간복잡도를 갖는다. 데이터의 상태가 어떻냐에 따라 달라짐.

더 많은 정렬법이 있지만 여기 있는 정렬만으로 이미 머리가 터질 것 같다.
다른 정렬법은 이 친구들을 다 이해한 후에 공부해도 될듯.
